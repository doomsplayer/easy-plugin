// Copyright 2016 Kyle Mayes
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

use std::collections::{HashMap};

use rustc_plugin::{Registry};

use syntax::ast::{Attribute, Expr, Ident, Item, Visibility};
use syntax::codemap::{Span, Spanned};
use syntax::ext::base::{ExtCtxt, DummyResult, MacEager, MacResult};
use syntax::ptr::{P};
use syntax::tokenstream::{TokenTree};
use syntax::util::small_vector::{SmallVector};

use ast::{ToExpr};

//================================================
// Functions
//================================================

/// Strips the visibility and attributes from a function and appends `_` to the name.
fn strip_function(
    context: &ExtCtxt, function: P<Item>
) -> (P<Item>, Ident, Option<Ident>, Vec<Attribute>) {
    let ident = function.ident;
    let visibility = if function.vis == Visibility::Public {
        Some(context.ident_of("pub"))
    } else {
        None
    };
    let attributes = function.attrs.clone();
    let function = function.map(|mut f| {
        f.ident = context.ident_of(&format!("{}_", ident.name));
        f.vis = Visibility::Inherited;
        f.attrs = vec![];
        f
    });
    (function, ident, visibility, attributes)
}

/// Returns a function that parse arguments according to the supplied specification.
fn expand_parse_fn(
    context: &ExtCtxt, span: Span, name: Ident, specification: Vec<Specifier>
) -> P<Item> {
    let expr = specification.to_expr(context, span);
    quote_item!(context,
        #[allow(non_snake_case)]
        fn parse(
            session: &::syntax::parse::ParseSess, arguments: &[::syntax::tokenstream::TokenTree]
        ) -> ::easy_plugin::PluginResult<$name> {
            let specification = $expr;
            ::easy_plugin::parse_arguments(session, arguments, &specification).map(|_a| {
                ${ast::expand_struct_expr(context, name, &specification)}
            })
        }
    ).unwrap()
}

/// Returns an expression that attempts to parse plugin arguments.
fn expand_parse_expr(context: &ExtCtxt, expr: P<Expr>) -> P<Expr> {
    quote_expr!(context,
        match $expr {
            Ok(result) => result,
            Err((subspan, message)) => {
                let span = if subspan == ::syntax::codemap::DUMMY_SP {
                    span
                } else {
                    subspan
                };
                context.span_err(span, &message);
                ::syntax::ext::base::DummyResult::any(span)
            },
        }
    )
}

fn expand_easy_plugin_(
    context: &mut ExtCtxt, span: Span, arguments: &[TokenTree]
) -> PluginResult<Box<MacResult + 'static>> {
    // Build the argument specification.
    let enums = HashMap::new();
    let specification = parse_specification_string(r#"
        $(enum $definition:ident { $($variant:ident { $($vtt:tt)* }), + $(,)* })*
        struct $arguments:ident { $($tt:tt)* }
        $function:item
    "#, &enums).unwrap();

    // Extract the arguments.
    let matches = try!(parse_arguments(context.parse_sess, arguments, &specification));
    let definitions = matches.get_sequence("definition").into_vec::<Spanned<Ident>>();
    let variants = matches.get_sequence("variant").into_sequence_vec(|s| {
        s.into_vec::<Spanned<Ident>>()
    });
    let vtts = matches.get_sequence("vtt").into_sequence_vec(|s| {
        s.into_sequence_vec(|s| s.into_vec::<TokenTree>())
    });
    let arguments = matches.get::<Spanned<Ident>>("arguments").node;
    let tts = matches.get_sequence("tt").into_vec::<TokenTree>();
    let function = matches.get::<P<Item>>("function");

    // Generate the plugin function.
    let mut enums = HashMap::new();
    for i in 0..definitions.len() {
        let mut subvariants = vec![];
        for (variant, tts) in variants[i].iter().zip(vtts[i].iter()) {
            let specification = try!(parse_specification(tts, &enums));
            subvariants.push(Variant::new(variant.node.name.as_str().to_string(), specification));
        }
        let name = definitions[i].node.name.as_str().to_string();
        enums.insert(name.clone(), Enum::new(name, subvariants));
    }
    let specification = try!(parse_specification(&tts, &enums));
    let (function, identifier, visibility, attributes) = strip_function(context, function);

    let expr = quote_expr!(context, |a| ${function.ident}(context, span, a));
    let expr = quote_expr!(context, parse(context.parse_sess, arguments).and_then($expr));
    let items = ast::expand_struct_items(context, arguments, &specification);

    let item = quote_item!(context,
        #[allow(non_camel_case_types)]
        $($attributes)*
        $visibility fn $identifier(
            context: &mut ::syntax::ext::base::ExtCtxt,
            span: ::syntax::codemap::Span,
            arguments: &[::syntax::tokenstream::TokenTree],
        ) -> Box<::syntax::ext::base::MacResult> {
            $($items)*
            ${expand_parse_fn(context, span, arguments, specification)}
            $function
            ${expand_parse_expr(context, expr)}
        }
    ).unwrap();
    Ok(MacEager::items(SmallVector::one(item)))
}

fn expand_easy_plugin<'cx>(
    context: &'cx mut ExtCtxt, span: Span, arguments: &[TokenTree]
) -> Box<MacResult + 'cx> {
    match expand_easy_plugin_(context, span, arguments) {
        Ok(result) => result,
        Err((span, message)) => {
            context.span_err(span, &message);
            DummyResult::any(span)
        },
    }
}

/// Add the `easy-plugin` plugins to the supplied registry.
#[cfg(feature="syntex")]
pub fn plugin_registrar(registry: &mut Registry) {
    registry.add_macro("easy_plugin", expand_easy_plugin);
}

/// Expand the supplied source file into the supplied destination file using the `easy-plugin`
/// plugins.
#[cfg(feature="syntex")]
pub fn expand<S: AsRef<std::path::Path>, D: AsRef<std::path::Path>>(
    source: S, destination: D
) -> Result<(), rustc_plugin::Error> {
    let mut registry = Registry::new();
    plugin_registrar(&mut registry);
    registry.expand("", source.as_ref(), destination.as_ref())
}

#[cfg(not(feature="syntex"))]
#[doc(hidden)]
#[plugin_registrar]
pub fn plugin_registrar(registry: &mut Registry) {
    registry.register_macro("easy_plugin", expand_easy_plugin);
}
