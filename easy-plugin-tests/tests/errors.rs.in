use easy_plugin;

use syntax::codemap::{BytePos};
use syntax::ext::base::{DummyMacroLoader, ExtCtxt};
use syntax::ext::expand::{ExpansionConfig};
use syntax::ext::quote::rt::{ExtParseUtils};
use syntax::parse::{ParseSess};

macro_rules! assert_error_eq {
    ($specification:expr, $lo:expr, $hi:expr, $source:expr, $message:expr) => ({
        let lo = BytePos($lo);
        let hi = BytePos($hi);
        let session = ParseSess::new();
        let config = ExpansionConfig::default("".into());
        let mut loader = DummyMacroLoader;
        let context = ExtCtxt::new(&session, vec![], config, &mut loader);
        let tts = context.parse_tts($source.into());
        match easy_plugin::parse_args(&session, &tts, $specification) {
            Err((span, message)) => if span.lo != lo || span.hi != hi || message != $message {
                println!("\n= Expected =========");
                println!("{:?}, {:?}: {:?}", lo, hi, $message);
                println!("= Generated ========");
                println!("{:?}, {:?}: {:?}", span.lo, span.hi, message);
                panic!();
            },
            _ => panic!("expected error"),
        }
    });
}

#[test]
fn test_errors() {
    let spec = parse_spec!();
    assert_error_eq!(&spec, 0, 3, "322", "too many arguments");
    assert_error_eq!(&spec, 0, 7, "322 644", "too many arguments");

    macro_rules! assert_errors_eq {
        ($spec:expr, $ty:expr, $valid:expr) => ({
            let spec = $spec;
            assert_error_eq!(&spec, 0, 0, "", concat!("expected ", $ty, ": 'a'"));
            assert_error_eq!(&spec, 0, 1, "?", concat!("expected ", $ty, ": 'a'"));
            let start = ($valid.len() as u32) + 1;
            assert_error_eq!(&spec, start, start + 1, concat!($valid, " !"), "too many arguments");
        });
    }

    let spec = parse_spec!($a:attr);
    assert_errors_eq!(&spec, "attribute", "#[cfg(test)]");
    let spec = parse_spec!($a:binop);
    assert_errors_eq!(&spec, "binary operator", "+");
    let spec = parse_spec!($a:block);
    assert_errors_eq!(&spec, "block", "{ let a = 322; }");
    let spec = parse_spec!($a:delim);
    assert_errors_eq!(&spec, "opening delimiter", "(1, 2, 3)");
    let spec = parse_spec!($a:expr);
    assert_errors_eq!(&spec, "expression", "2 + 2");
    let spec = parse_spec!($a:ident);
    assert_errors_eq!(&spec, "identifier", "a");
    let spec = parse_spec!($a:item);
    assert_errors_eq!(&spec, "item", "struct A;");
    let spec = parse_spec!($a:lftm);
    assert_errors_eq!(&spec, "lifetime", "'a");
    let spec = parse_spec!($a:lit);
    assert_errors_eq!(&spec, "literal", "322");
    let spec = parse_spec!($a:meta);
    assert_errors_eq!(&spec, "meta item", "cfg(test)");
    let spec = parse_spec!($a:pat);
    assert_errors_eq!(&spec, "pattern", "_");
    let spec = parse_spec!($a:path);
    assert_errors_eq!(&spec, "path", "::std::path::Path");
    let spec = parse_spec!($a:stmt);
    assert_errors_eq!(&spec, "statement", "let a = 322");
    let spec = parse_spec!($a:ty);
    assert_errors_eq!(&spec, "type", "(i32, f32)");

    let spec = parse_spec!($a:attr_list);
    assert_error_eq!(&spec, 0, 7, "#[test]", "expected `MetaItemKind::List` attr");
    let spec = parse_spec!($a:expr_addr_of);
    assert_error_eq!(&spec, 0, 5, "2 + 2", "expected `ExprKind::AddrOf` expr");
    let spec = parse_spec!($a:item_const);
    assert_error_eq!(&spec, 0, 14, "struct Struct;", "expected `ItemKind::Const` item");
    let spec = parse_spec!($a:lit_bool);
    assert_error_eq!(&spec, 0, 3, "322", "expected `LitKind::Bool` lit");
    let spec = parse_spec!($a:meta_list);
    assert_error_eq!(&spec, 0, 4, "test", "expected `MetaItemKind::List` meta");
    let spec = parse_spec!($a:pat_ident);
    assert_error_eq!(&spec, 0, 6, "(a, b)", "expected `PatKind::Ident` pat");
    let spec = parse_spec!($a:stmt_expr);
    assert_error_eq!(&spec, 0, 9, "let a = b;", "expected `StmtKind::Expr` stmt");
    let spec = parse_spec!($a:tok_and_and);
    assert_error_eq!(&spec, 0, 1, "!", "expected `Token::AndAnd` tok");
    let spec = parse_spec!($a:tt_delimited);
    assert_error_eq!(&spec, 0, 1, "!", "expected `TokenTree::Delimited` tt");
    let spec = parse_spec!($a:ty_bare_fn);
    assert_error_eq!(&spec, 0, 3, "i32", "expected `TyKind::BareFn` ty");

    let spec = parse_spec!($a:tok);
    assert_error_eq!(&spec, 0, 0, "", "expected token: 'a'");
    let spec = parse_spec!($a:tt);
    assert_error_eq!(&spec, 0, 0, "", "expected token tree: 'a'");

    let spec = parse_spec!(?);
    assert_error_eq!(&spec, 0, 0, "", "expected `?`");
    assert_error_eq!(&spec, 0, 1, "!", "expected `?`");
    assert_error_eq!(&spec, 1, 2, "?!", "too many arguments");

    let spec = parse_spec!(($a:ident));
    assert_error_eq!(&spec, 0, 0, "", "expected `(`");
    assert_error_eq!(&spec, 0, 1, "!", "expected `(`");
    assert_error_eq!(&spec, 2, 3, "(a!)", "expected `)`");
    assert_error_eq!(&spec, 3, 4, "(a)!", "too many arguments");

    let spec = parse_spec!($($a:ident)+);
    assert_error_eq!(&spec, 0, 0, "", "expected identifier: 'a'");
    assert_error_eq!(&spec, 1, 2, "a!", "too many arguments");
    assert_error_eq!(&spec, 3, 4, "a b!", "too many arguments");

    let spec = parse_spec!($($a:ident)*);
    assert_error_eq!(&spec, 1, 2, "a!", "too many arguments");
    assert_error_eq!(&spec, 3, 4, "a b!", "too many arguments");

    let spec = parse_spec!($($a:ident)?);
    assert_error_eq!(&spec, 2, 3, "a b", "too many arguments");
}
