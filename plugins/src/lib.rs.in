// Copyright 2016 Kyle Mayes
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

use std::rc::{Rc};

use rustc_plugin::{Registry};

use syntax::print::pprust;
use syntax::ast::*;
use syntax::codemap::{self, Span};
use syntax::ext::base::{ExtCtxt, MacEager, MacResult};
use syntax::ext::build::{AstBuilder};
use syntax::parse::token::{self, Token};
use syntax::ptr::{P};
use syntax::tokenstream::{Delimited, TokenTree};
use syntax::util::small_vector::{SmallVector};

//================================================
// Enums
//================================================

// Call __________________________________________

/// Indicates the methods to be called on a value to return it from a converter function.
#[derive(Copy, Clone, Debug)]
enum Call {
    Clone,
    ToString,
    AsStrToString,
    MapAsStrToString,
}

impl Call {
    //- Constructors -----------------------------

    fn from_specifier(specifier: &str) -> Call {
        match specifier {
            "ts" => Call::ToString,
            "asts" => Call::AsStrToString,
            "masts" => Call::MapAsStrToString,
            _ => Call::Clone,
        }
    }

    //- Accessors --------------------------------

    fn to_expr(self, context: &ExtCtxt, ident: Ident) -> P<Expr> {
        match self {
            Call::Clone => quote_expr!(context, $ident.clone()),
            Call::ToString => quote_expr!(context, $ident.to_string()),
            Call::AsStrToString => quote_expr!(context, $ident.as_str().to_string()),
            Call::MapAsStrToString => quote_expr!(context, $ident.map(|f| f.as_str().to_string())),
        }
    }
}

//================================================
// Structs
//================================================

// Converter _____________________________________

/// A conversion function.
#[derive(Clone, Debug)]
struct Converter {
    pub name: Ident,
    pub arguments: Vec<(Ident, Call)>,
    pub rty: P<Ty>,
}

impl Converter {
    //- Constructors -----------------------------

    fn parse(context: &ExtCtxt, tts: &[TokenTree]) -> Converter {
        let name = to_ident(&tts[0]);
        let arguments = to_delimited(&tts[1]).tts.iter().filter_map(|tt| {
            match tt {
                &TokenTree::Token(_, Token::Underscore) => Some("_".into()),
                &TokenTree::Token(_, Token::Ident(ref ident)) => Some(ident.name.as_str().to_string()),
                _ => None,
            }
        }).enumerate().map(|(i, s)| {
            let mut buffer = String::new();
            buffer.push(((97 + i) as u8) as char);
            (context.ident_of(&buffer), Call::from_specifier(&s))
        }).collect::<Vec<_>>();
        Converter { name: name, arguments: arguments, rty: parse_ty(context, &tts[3..4]) }
    }
}

// ConverterSet __________________________________

/// A set of conversion functions.
#[derive(Clone, Debug)]
struct ConverterSet {
    pub name: Ident,
    pub converters: Vec<Converter>,
    pub pname: Ident,
    pub pty: P<Ty>,
    pub pexpr: P<Expr>,
}

impl ConverterSet {
    //- Constructors -----------------------------

    fn parse(context: &ExtCtxt, tts: &[TokenTree]) -> ConverterSet {
        let name = to_ident(&tts[5]);
        let converters = to_delimited(&tts[7]).tts.chunks(5).map(|tts| {
            Converter::parse(context, tts)
        }).collect();
        let pname = to_ident(&tts[0]);
        let pty = match &tts[2] {
            &TokenTree::Delimited(_, ref delimited) => quote_ty!(context, $(${delimited.tts})*),
            tt => quote_ty!(context, $tt),
        };
        let pexpr = parse_expr(context, &to_delimited(&tts[3]).tts[..]);
        ConverterSet { name: name, converters: converters, pname: pname, pty: pty, pexpr: pexpr }
    }
}

//================================================
// Functions
//================================================

fn get_doc_comment(context: &ExtCtxt, span: Span, value: &str) -> P<MetaItem> {
    let value = LitKind::Str(token::intern_and_get_ident(value), StrStyle::Cooked);
    context.meta_name_value(span, token::intern_and_get_ident("doc"), value)
}

fn get_lit_str(span: Span, value: &str) -> Lit {
    codemap::respan(span, LitKind::Str(token::intern_and_get_ident(value), StrStyle::Cooked))
}

fn parse_expr(context: &ExtCtxt, tts: &[TokenTree]) -> P<Expr> {
    context.new_parser_from_tts(tts).parse_expr().unwrap()
}

fn parse_ty(context: &ExtCtxt, tts: &[TokenTree]) -> P<Ty> {
    context.new_parser_from_tts(tts).parse_ty().unwrap()
}

fn to_delimited(tt: &TokenTree) -> Rc<Delimited> {
    match tt {
        &TokenTree::Delimited(_, ref delimited) => delimited.clone(),
        _ => unreachable!(),
    }
}

fn to_ident(tt: &TokenTree) -> Ident {
    match tt {
        &TokenTree::Token(_, Token::Ident(ref name)) => name.clone(),
        _ => unreachable!(),
    }
}

fn camel_case_to_snake_case(ident: Ident) -> String {
    let mut snake = String::new();
    for c in ident.name.as_str().chars() {
        if c.is_uppercase() {
            if !snake.is_empty() {
                snake.push('_');
            }
            snake.extend(c.to_lowercase());
        } else {
            snake.push(c);
        }
    }
    snake
}

/// Returns a doc comment meta item with appropriate documentation for a converter function.
fn expand_convert_fn_doc_comment(
    context: &mut ExtCtxt, span: Span, set: &ConverterSet, converter: &Converter
) -> P<MetaItem> {
    let ty = pprust::ty_to_string(&set.pty);
    let doc = match converter.arguments.len() {
        0 => format!("Returns `Ok` if the supplied `{}` is `{}::{}`", ty, set.name, converter.name),
        1 => format!("Returns the `{}::{}` value in the supplied `{}`.", set.name, converter.name, ty),
        _ => format!("Returns the `{}::{}` values in the supplied `{}`.", set.name, converter.name, ty),
    };
    get_doc_comment(context, span, &doc)
}

/// Returns a converter function item.
fn expand_convert_fn(
    context: &mut ExtCtxt, span: Span, set: &ConverterSet, converter: &Converter
) -> P<Item> {
    // Build the documentation.
    let doc = expand_convert_fn_doc_comment(context, span, set, converter);

    // Build the name.
    let name = context.ident_of(&format!("{}_to_{}", set.pname, camel_case_to_snake_case(converter.name)));

    // Build the variant pat.
    let idents = vec![set.name, converter.name];
    let path = context.path_all(span, false, idents, vec![], vec![], vec![]);
    let pats = converter.arguments.iter().map(|&(ref p, _)| quote_pat!(context, ref $p)).collect();
    let pat = context.pat_enum(span, path, pats);

    // Build the expr that returns the variant fields.
    let mut exprs = converter.arguments.iter().map(|&(ref p, ref c)| {
        c.to_expr(context, *p)
    }).collect::<Vec<_>>();
    let expr = if exprs.len() == 1 {
        exprs.remove(0)
    } else {
        context.expr_tuple(span, exprs)
    };

    // Build the error message.
    let message = get_lit_str(span, &format!("expected `{}::{}` {}", set.name, converter.name, set.pname));

    // Build the converter function item.
    quote_item!(context,
        #[$doc]
        pub fn $name(${set.pname}: &${set.pty}) -> PluginResult<${converter.rty}> {
            match ${set.pexpr} {
                $pat => Ok($expr),
                _ => ${set.pname}.to_error($message),
            }
        }
    ).unwrap()
}

/// Returns an exhaustive function that ensures all variants are accounted for.
fn expand_convert_exhaustive_fn(context: &mut ExtCtxt, set: &ConverterSet) -> P<Item> {
    // Build the name.
    let name = context.ident_of(&format!("{}_exhaustive", set.pname));

    // Build the variants.
    let variants = set.converters.iter().map(|c| {
        match c.rty.node {
            TyKind::Tup(ref tys) if tys.is_empty() => quote_arm!(context, ${set.name}::${c.name} => { }),
            _ => quote_arm!(context, ${set.name}::${c.name}(..) => { }),
        }
    }).collect::<Vec<_>>();

    // Build the exhaustive converter function item.
    quote_item!(context,
        #[allow(dead_code)]
        fn $name(${set.pname}: &${set.pty}) {
            match ${set.pexpr} {
                $($variants)*
            }
        }
    ).unwrap()
}

/// Returns converter function items.
///
/// A converter function attempts to extract the values in the `node` of an AST element. For
/// example, `expr_to_vec` takes an `&Expr` and returns a `PluginResult<Vec<P<Expr>>>`. If the
/// `node` in the supplied `&Expr` is the `ExprKind::Vec` variant, the value contained in the
/// variant is returned as an `Ok` value. Otherwise, an `Err` value is returned.
fn expand_convert<'cx>(
    context: &'cx mut ExtCtxt, span: Span, arguments: &[TokenTree]
) -> Box<MacResult + 'cx> {
    let sets = arguments.chunks(9).map(|tts| ConverterSet::parse(context, tts)).collect::<Vec<_>>();
    let mut items = vec![];
    for set in &sets {
        items.push(expand_convert_exhaustive_fn(context, set));
        for converter in &set.converters {
            items.push(expand_convert_fn(context, span, set, converter));
        }
    }
    MacEager::items(SmallVector::many(items))
}

#[cfg(feature="syntex")]
pub fn plugin_registrar(registry: &mut Registry) {
    registry.add_macro("__easy_plugin_convert", expand_convert);
}

#[cfg(feature="syntex")]
pub fn expand<S: AsRef<std::path::Path>, D: AsRef<std::path::Path>>(
    source: S, destination: D
) -> Result<(), rustc_plugin::Error> {
    let mut registry = Registry::new();
    plugin_registrar(&mut registry);
    registry.expand("", source.as_ref(), destination.as_ref())
}

#[cfg(not(feature="syntex"))]
#[doc(hidden)]
#[plugin_registrar]
pub fn plugin_registrar(registry: &mut Registry) {
    registry.register_macro("__easy_plugin_convert", expand_convert);
}
